# 所谓时间复杂度

描述算法效率的名词。次数越高，复杂度越大。

时间复杂度 = **子问题的个数** x **解决一个子问题所需的时间**

# 所谓空间复杂度

空间复杂度 = **子问题的个数** x **解决一个子问题所需的内存空间**

# 举个例子:斐波拉契数列

数学公式：

<img src="D:\studydemo\作战计划\planOfInterviewReview\算法方面\算法基础.assets\image-20200422151048373.png" alt="image-20200422151048373" style="zoom:67%;" />

利用递归算法来编程就是如下写法：

```kotlin
fun fib1(x: Int): Long {
    return if (x == 1 || x == 2) {
        1
    } else
        fib1(x - 1) + fib1(x - 2)
}
```

如果用上面的算法来计算斐波拉契数列中某个节点的值，我们来算算时间复杂度是多少。

如果是f(20),那么递归树结构就是：

<img src="D:\studydemo\作战计划\planOfInterviewReview\算法方面\算法基础.assets\image-20200422112357142.png" alt="image-20200422112357142" style="zoom:67%;" />

- 一个问题，都会分裂成2个子问题。所以子问题的个数是2的n次方。

- 解决一个子问题，只需要一次加法，并没有涉及到循环。所以，解决一个子问题的时间是1

合并起来，时间复杂度就是O(2^n) 指数级别的复杂度，效率极低。

从上面的图可以看出，很多子问题都是重复计算的。比如f(18),f(17)...这就是上面的算法所带来的低效率问题，在做很多不必要的重复性工作。

空间复杂度（O(1)）这里不谈，因为都是临时变量，不存在永久保存的数据。

## 如何改进

既然上面的f(17),f(18)等都在重复计算，那么我们用一个备忘录，记录已经计算出的结果。

比如把上面的f(18)的值记录下来，下次需要计算的时候，直接取值。

程序变成这样：

```kotlin
fun fib2(x: Int): Long {
    if (x < 1) return 0
    val map = HashMap<Int, Long>()
    return helper(map, x)
}

fun helper(map: HashMap<Int, Long>, x: Int): Long {
    if (x == 1 || x == 2) return 1
    if (map[x] != null && map[x] != 0L) //如果已经计算过了，那就是说保存过了，就直接返回
        return map[x]!!
    // 否则，就计算之后再保存
    map[x] = helper(map, x - 1) + helper(map, x - 2) // 这里依然是递归
    return map[x]!!
}
```

这种解法的时间复杂度该如何计算？

上面的做法，显然就是f(18)等这种重复性计算不再存在，所以可以理解为：当需要f(18)的时候，会优先从 备忘录vector中去取。所以，计算出f(20)，也就最多有20个子问题。所以

- f(n)子问题的个数是 n,

- 解决子问题的时间也还是1，

  所以时间复杂度是 O(n) , 对比 前面一种解法的O(2^n)简直就是降维打击。

而**空间复杂度**：

由于这里使用了 Vector集合来保存已经计算出来的值，所以，空间复杂度：

- f(n)子问题的个数还是n
- 每一个子问题都会占用1个空间

所以空间复杂度= O(n)

## 还能改进?

上面的做法依然是和第一种写法一样的从上往下的递归，要求 f(20)首先要知道f(19) f(18),而知道f(19)又必须先知道f(18)和f(17)...那么我们能不能倒过来? f(1)和f(2)都是1，f(3)=f(1)+f(2),f(4)=f(2)+f(3)...如果从下往上推算，是不是也用不着去 用 上面说的vector去保存已经计算出来的数据了？

程序写成下面这样:

```kotlin
fun fib3(x: Int): Long {

    val map = HashMap<Int, Long>() // 初始化一个map

    map[1] = 1
    map[2] = 1

    for (i in 3..x) {
        val pre1 = map[i - 1] ?: 0
        val pre2 = map[i - 2] ?: 0
        map[i] = pre1 + pre2
    }
    return map[x] ?: 0

}
```

时间复杂度：

- 子问题的个数依然是N
- 处理一个子问题的，没有循环，时间依然是1

所以时间复杂度依然是：O(n)

空间复杂度:

- 子问题的个数是N
- 处理一个子问题，需要保存一个数据，所以占空间是1

空间复杂度为：O(n)

## 最后的改进

上面一种改进方法，我们用vector保存了已经计算出来的值，自上而下计算，和自下而上计算，时间和空间复杂度都相同。但是，自下而上的计算依然有优化空间。思考:是否可以不需要vector来保存数据？

上一节的改进，f(n)依赖的仅仅是f(n-1)和f(n-2). 而不需要另外的数据一直保存。

```kotlin
/**
 * 最后优化
 */
fun fib4(x: Int): Long {
    if (x == 1 || x == 2) return 1L
    var cur = 1L
    var pre = 1L
    for (i in 3..x) {
        val sum = cur + pre
        pre = cur
        cur = sum
    }
    return cur
}
```

时间复杂度：

- 子问题的个数是n
- 解决一个子问题所需的时间是1

所以时间复杂度是O(n)

空间复杂度：

- 子问题的个数是n
- 一个子问题所占用的空间是1，但是 都是临时占用，函数执行完毕之后就会释放，算法中的临时变量所占空间并不会累加，

所以空间复杂度，是O(1)

## 测试结果

先摆出所有的测试代码（kotlin）

```kotlin
package com.zhou.myapplication

import android.annotation.SuppressLint
import java.text.SimpleDateFormat
import java.util.*
import kotlin.collections.HashMap


/**
 * 扩展Long的一个方法，将本身转化成日期时间格式的字符串
 */
@SuppressLint("SimpleDateFormat")
fun Long.transTimeStamp(): String {
    return SimpleDateFormat("yyyy-MM-dd HH:mm:ss").format(Date(this))
}

fun Long.isCurrentDay(arg: Long): Boolean {

    val yyyyMMdd = SimpleDateFormat("yyyy-MM-dd")
    val formatThis = yyyyMMdd.format(Date(this))
    val formatArg = yyyyMMdd.format(Date(arg))
    return formatThis == formatArg
}

/**
 * 试试斐波拉契数列
 */
fun main() {
    var startTime = 0L
    val x = 900
//    println("===========粗暴的递归解法：=========")
//    var startTime = System.currentTimeMillis()
//    println("计算开始，启动时间是：${startTime.transTimeStamp()}")
//    println("计算结果是：${fib1(50)}")
//    println("计算完成，现在是${System.currentTimeMillis().transTimeStamp()}，一共耗时${(System.currentTimeMillis() - startTime) / 1000.0}秒")

    println("===========改良后的粗暴的递归解法：=========")
    startTime = System.currentTimeMillis()
    println("计算开始，启动时间是：${startTime.transTimeStamp()}")
    println("计算结果是：${fib2(x)}")
    println("计算完成，现在是${System.currentTimeMillis().transTimeStamp()}，一共耗时${(System.currentTimeMillis() - startTime) / 1000.0}秒")

    println("===========采用自下而上的计算方法：=========")
    startTime = System.currentTimeMillis()
    println("计算开始，启动时间是：${startTime.transTimeStamp()}")
    println("计算结果是：${fib3(x)}")
    println("计算完成，现在是${System.currentTimeMillis().transTimeStamp()}，一共耗时${(System.currentTimeMillis() - startTime) / 1000.0}秒")

    println("===========采用自下而上的计算方法(空间优化版)：=========")
    startTime = System.currentTimeMillis()
    println("计算开始，启动时间是：${startTime.transTimeStamp()}")
    println("计算结果是：${fib4(x)}")
    println("计算完成，现在是${System.currentTimeMillis().transTimeStamp()}，一共耗时${(System.currentTimeMillis() - startTime) / 1000.0}秒")

}

/**
 * 自上而下的递归算法, 也是最暴力的解法
 *
 * f(n) = if(n=1||n==2)1
 *  else {
 *      f(n-1)+f(n-2)
 *  }
 *
 *  时间复杂度O(2^n)
 */
fun fib1(x: Int): Long {
    return if (x == 1 || x == 2) {
        1
    } else
        fib1(x - 1) + fib1(x - 2)
}

/**
 * 由于存在大量重复计算，现在使用备忘录，记录下已经计算出的数值
 */
fun fib2(x: Int): Long {
    if (x < 1) return 0
    val map = HashMap<Int, Long>()
    return helper(map, x)
}

fun helper(map: HashMap<Int, Long>, x: Int): Long {
    if (x == 1 || x == 2) return 1
    if (map[x] != null && map[x] != 0L) //如果已经计算过了，那就是说保存过了，就直接返回
        return map[x]!!
    // 否则，就计算之后再保存
    map[x] = helper(map, x - 1) + helper(map, x - 2) // 这里依然是递归
    return map[x]!!
}

/**
 * 趁他还在计算，我们来写第三种解法，上面用一个map来记录了已经计算出的值，避免重复计算，可以节省不少时间，但是依然可以优化。
 *
 * 上面的解法都是涉及到递归，递归就是自上而下的计算，然后由下往上回传。
 *
 * 那么可不可以自下而上直接计算呢？
 */
fun fib3(x: Int): Long {

    val map = HashMap<Int, Long>() // 初始化一个map

    map[1] = 1
    map[2] = 1

    for (i in 3..x) {
        val pre1 = map[i - 1] ?: 0
        val pre2 = map[i - 2] ?: 0
        map[i] = pre1 + pre2
    }
    return map[x] ?: 0

}

/**
 * 最后优化算法
 */
fun fib4(x: Int): Long {
    if (x == 1 || x == 2) return 1L
    var cur = 1L
    var pre = 1L
    for (i in 3..x) {
        val sum = cur + pre
        pre = cur
        cur = sum
    }
    return cur
}
```

结果：

```java
===========改良后的粗暴的递归解法：=========
计算开始，启动时间是：2020-04-22 16:31:25
计算结果是：5855021214961818160
计算完成，现在是2020-04-22 16:31:26，一共耗时0.026秒
===========采用自下而上的计算方法：=========
计算开始，启动时间是：2020-04-22 16:31:26
计算结果是：5855021214961818160
计算完成，现在是2020-04-22 16:31:26，一共耗时0.0秒
===========采用自下而上的计算方法(空间优化版)：=========
计算开始，启动时间是：2020-04-22 16:31:26
计算结果是：5855021214961818160
计算完成，现在是2020-04-22 16:31:26，一共耗时0.0秒
```

上述4种解法：第一种暴力递归法，由于我这里参数N是900，之前我单独测的时候，N为50，耗时就已经超过了30秒，可见暴力解法的效率有多低。

可以看到，在N=900的情况下，后3种解法（自上而下hashMap解法，自下而上的hashMap存数据解法， 不用hashmap的自下而上解法），效率都很高，递归的效率稍低。后面两种，几乎是秒解。

# 再举个例子：凑零钱

一张大钞，要换算成零钱。

伪代码：

```kotlin
  val coins = [1,2,5]
  res = Long.maxvalue.
  f(n) = if(n=0) return 0 (目标金额是0，那就不需要凑，返回0)
         if(n<0) return -1(目标金额是负数，异常情况，返回-1)
         if(n>0) {
            for(i in coins){
               res = min(res,1+ f(n-coin))
            }
            return res
      }
```



时间复杂度：

- 子问题的个数是 (假设零钱分为n类，数量不限) 分裂次数不确，假设次数是，那么子问题的总数就是 n^k，总之这是一个指数级别的数字
- 解决一个子问题所需的时间，一个要分裂成n个子问题，由于有循环递归，所以解决一个子问题实际上需要的时间是n

所以，时间复杂度就是`O(n*n^k)`

空间复杂度：

由于没有数据保存，一律人为空间复杂度是O(1)

改成kotlin写法就是：

```kotlin
val change = arrayOf(1, 2, 5) // 零钱就是1,2,5

/**
 * @param targetAmount 要用零钱凑成的目标金额
 */
fun changeMoney(targetAmount: Long): Int {
    var finalCount = Int.MAX_VALUE // 由于要计算出最小值，所以先初始化为最大值
    if (targetAmount == 0L) return 0 // 贼
    if (targetAmount < 0) return -1
    for (c in change) {
        val subRes = changeMoney(targetAmount - c)
        if (subRes == -1) continue
        finalCount = min(finalCount, 1 + subRes)
    }
    println("计算过程：$finalCount")
    return finalCount
}

fun main() {
    val changeMoney = changeMoney(11)
    println("凑成目标金额所需的最小零钱数：$changeMoney")
}
```

11块钱，拆分成零钱，最小数目是3个，2个5，一个1.符合预期。但是从执行日志上来看，很简单的运算，执行了很多次。毕竟递归算法有很多重复算法.

## 如何改进

参考上一个例子的改进方法，依然先使用自上而下的递归，加上 去重手段，保存已经计算出的值。













